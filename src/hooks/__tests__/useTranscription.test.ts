import { renderHook, act } from '@testing-library/react-hooks';
import { useTranscription } from '../useTranscription';
import { AudioExtractor } from '../../services/audioExtractor';
import { OpenAIService } from '../../services/openaiService';
import type { VideoTranscript } from '../../features/learning-path/types';
import { OpenAIError } from '../../services/openaiService';

// Mock dependencies
jest.mock('../../services/audioExtractor');
jest.mock('../../services/openaiService');

// Mock File and Blob since they're not available in Node.js
global.File = class MockFile {
  name: string;
  type: string;
  size: number;
  lastModified: number;
  private content: string[];

  constructor(content: string[], name: string, options: { type: string }) {
    this.content = content;
    this.name = name;
    this.type = options.type;
    this.size = content.join('').length;
    this.lastModified = Date.now();
  }
} as unknown as typeof File;

global.Blob = class MockBlob {
  size: number;
  type: string;
  private content: string[];

  constructor(content: string[], options: { type: string }) {
    this.content = content;
    this.type = options.type;
    this.size = content.join('').length;
  }
} as unknown as typeof Blob;

describe('useTranscription', () => {
  let mockExtractAudio: jest.Mock;
  let mockTranscribeAudio: jest.Mock;
  let mockAnalyzeTranscription: jest.Mock;
  let mockCleanup: jest.Mock;

  beforeEach(() => {
    // Setup mock implementations
    mockExtractAudio = jest.fn();
    mockTranscribeAudio = jest.fn();
    mockAnalyzeTranscription = jest.fn();
    mockCleanup = jest.fn();

    (AudioExtractor as jest.Mock).mockImplementation(() => ({
      extractAudio: mockExtractAudio,
      onProgress: jest.fn(),
      cleanup: mockCleanup
    }));

    (OpenAIService as jest.Mock).mockImplementation(() => ({
      transcribeAudio: mockTranscribeAudio,
      analyzeTranscription: mockAnalyzeTranscription
    }));
  });

  it('should initialize with default values', () => {
    const { result } = renderHook(() => useTranscription());

    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBeNull();
    expect(result.current.progress).toBe(0);
    expect(typeof result.current.transcribe).toBe('function');
  });

  it('should handle successful transcription flow', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const mockTranscriptionText = 'This is a test transcription';

    mockExtractAudio.mockResolvedValue(mockAudioBlob);
    mockTranscribeAudio.mockResolvedValue(mockTranscriptionText);

    const { result } = renderHook(() => useTranscription());

    const expectedTranscript: VideoTranscript = {
      videoId: expect.any(String),
      segments: [{
        startTime: 0,
        endTime: expect.any(Number),
        text: mockTranscriptionText
      }],
      language: 'en',
      isAutogenerated: true
    };

    let transcript: VideoTranscript;
    await act(async () => {
      transcript = await result.current.transcribe(mockFile);
    });

    expect(mockExtractAudio).toHaveBeenCalledWith(mockFile);
    expect(mockTranscribeAudio).toHaveBeenCalledWith(mockAudioBlob);
    expect(transcript!).toEqual(expectedTranscript);
    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBeNull();
  });

  it('should handle audio extraction error', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const error = new Error('Audio extraction failed');
    mockExtractAudio.mockRejectedValue(error);

    const { result } = renderHook(() => useTranscription());

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(result.current.error).toBe('Audio extraction failed');
    expect(result.current.isLoading).toBe(false);
    expect(mockTranscribeAudio).not.toHaveBeenCalled();
  });

  it('should handle transcription error', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const error = new Error('Transcription failed');

    mockExtractAudio.mockResolvedValue(mockAudioBlob);
    mockTranscribeAudio.mockRejectedValue(error);

    const { result } = renderHook(() => useTranscription());

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(result.current.error).toBe('Transcription failed');
    expect(result.current.isLoading).toBe(false);
  });

  it('should update progress during extraction', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const mockTranscriptionText = 'This is a test transcription';

    mockExtractAudio.mockImplementation(async (file, onProgress) => {
      onProgress(0.5);
      return mockAudioBlob;
    });
    mockTranscribeAudio.mockResolvedValue(mockTranscriptionText);

    const { result } = renderHook(() => useTranscription());

    await act(async () => {
      await result.current.transcribe(mockFile);
    });

    expect(result.current.progress).toBe(0.5);
  });

  it('should cleanup on unmount', () => {
    const { unmount } = renderHook(() => useTranscription());

    // Verify that the cleanup function was called
    unmount();
    expect(mockCleanup).toHaveBeenCalled();
  });

  it('should handle invalid file type', async () => {
    const mockFile = new File(['test'], 'test.txt', { type: 'text/plain' });
    const { result } = renderHook(() => useTranscription());

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(result.current.error).toBe('Invalid file type. Please provide a video file.');
    expect(result.current.isLoading).toBe(false);
    expect(mockExtractAudio).not.toHaveBeenCalled();
  });

  it('should handle empty file', async () => {
    const mockFile = new File([], 'test.mp4', { type: 'video/mp4' });
    const { result } = renderHook(() => useTranscription());

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(result.current.error).toBe('Invalid file. The file is empty.');
    expect(result.current.isLoading).toBe(false);
    expect(mockExtractAudio).not.toHaveBeenCalled();
  });

  it('should handle file size limit error', async () => {
    const mockFile = new File(['test'.repeat(1000000)], 'large.mp4', { type: 'video/mp4' });
    const error = new OpenAIError('File size exceeds limit', 'openai/api-error');
    mockTranscribeAudio.mockRejectedValue(error);

    const onError = jest.fn();
    const { result } = renderHook(() => useTranscription({ onError }));

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(onError).toHaveBeenCalledWith(error);
    expect(result.current.error).toBe(error);
    expect(result.current.isLoading).toBe(false);
  });

  it('should handle unsupported audio format error', async () => {
    const mockFile = new File(['test'], 'audio.wav', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/wav' });
    const error = new OpenAIError('Unsupported media type', 'openai/api-error');

    mockExtractAudio.mockResolvedValue(mockAudioBlob);
    mockTranscribeAudio.mockRejectedValue(error);

    const onError = jest.fn();
    const { result } = renderHook(() => useTranscription({ onError }));

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(onError).toHaveBeenCalledWith(error);
    expect(result.current.error).toBe(error);
    expect(result.current.isLoading).toBe(false);
  });

  it('should handle empty transcription error', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const error = new OpenAIError('Empty transcription text', 'openai/invalid-response');

    mockExtractAudio.mockResolvedValue(mockAudioBlob);
    mockTranscribeAudio.mockResolvedValue('');
    mockAnalyzeTranscription.mockRejectedValue(error);

    const onError = jest.fn();
    const { result } = renderHook(() => useTranscription({ onError }));

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(onError).toHaveBeenCalledWith(error);
    expect(result.current.error).toBe(error);
    expect(result.current.isLoading).toBe(false);
  });

  it('should handle invalid chapter data error', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const error = new OpenAIError('Invalid chapter timestamps', 'openai/invalid-response');

    mockExtractAudio.mockResolvedValue(mockAudioBlob);
    mockTranscribeAudio.mockResolvedValue('test transcription');
    mockAnalyzeTranscription.mockRejectedValue(error);

    const onError = jest.fn();
    const { result } = renderHook(() => useTranscription({ onError }));

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(onError).toHaveBeenCalledWith(error);
    expect(result.current.error).toBe(error);
    expect(result.current.isLoading).toBe(false);
  });

  it('should handle overlapping chapter timestamps error', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const error = new OpenAIError('Chapter timestamps must be sequential', 'openai/invalid-response');

    mockExtractAudio.mockResolvedValue(mockAudioBlob);
    mockTranscribeAudio.mockResolvedValue('test transcription');
    mockAnalyzeTranscription.mockRejectedValue(error);

    const onError = jest.fn();
    const { result } = renderHook(() => useTranscription({ onError }));

    await act(async () => {
      try {
        await result.current.transcribe(mockFile);
        fail('Should have thrown an error');
      } catch (error) {
        // Expected error
      }
    });

    expect(onError).toHaveBeenCalledWith(error);
    expect(result.current.error).toBe(error);
    expect(result.current.isLoading).toBe(false);
  });

  it('should update progress correctly through all stages', async () => {
    const mockFile = new File(['test'], 'test.mp4', { type: 'video/mp4' });
    const mockAudioBlob = new Blob(['audio'], { type: 'audio/mp3' });
    const mockTranscriptionText = 'This is a test transcription';
    const mockAnalysis = {
      summary: 'Test summary',
      keywords: ['test'],
      chapters: [{ title: 'Chapter 1', startTime: 0, endTime: 10 }]
    };

    mockExtractAudio.mockImplementation(async (file, onProgress) => {
      onProgress(50); // 50% of audio extraction (25% of total)
      return mockAudioBlob;
    });
    mockTranscribeAudio.mockResolvedValue(mockTranscriptionText);
    mockAnalyzeTranscription.mockResolvedValue(mockAnalysis);

    const onProgress = jest.fn();
    const { result } = renderHook(() => useTranscription({ onProgress }));

    await act(async () => {
      await result.current.transcribe(mockFile);
    });

    expect(onProgress).toHaveBeenCalledWith(25); // 50% of audio extraction
    expect(onProgress).toHaveBeenCalledWith(50); // Audio extraction complete
    expect(onProgress).toHaveBeenCalledWith(75); // Transcription complete
    expect(onProgress).toHaveBeenCalledWith(100); // Analysis complete
    expect(result.current.progress).toBe(100);
  });
}); 